#pragma warning(disable : 4996)
#include<stdio.h>
#include<conio.h>

void main
{
// pointer array
	// 1.
	/*
	char name[10], * irum;

	irum = "강호동";	// 정리 : 포인터 변수 = 포인터 상수 >> 가능
	// 문자열은 포인터임
	// 변수에 문자열을 담으면 문자열의 주소값이 변수에 저장되는 것임
	

	name = "홍길동";	// 정리 : 포인터 상수 = 포인터 상수 >> 불가능
	// 포인터 상수는 주소값을 의미함
	// 배열을 포인터 상수에 넣는 방법 >> strcpy(name, "홍길동");	cf) #include<string.h>사용해야함

	printf("난 %s이고 넌 %s이다\n", irum, name);
	*/

	// 2.
	/*
	char* str[3] = { "program", "cobol", "MBC" };

	printf("str[1] = %s\n", str[1]); // >> cobol

	printf("*str[1] = %c\n", *str[1]); // >> c
	// 간접연산자를 통해 데이터로 직접가면 ‘문자’를 받음
	// 간접연산자없이 주소값으로 가면, 해당 주소값부터 null값까지 받음(문자열)	-> 아래 '정리'에서 자세히 설명
	// *(str[1] + 1) >> 만약 str[1]의 주소값이 2000번지라고 가정했을때, 이건 2001번지의 문자를 출력함 cf) 서식문자열로 %c를 사용해야함
	// (str[1] + 2) >> 2002번지부터 null값까지 출력함 cf) 서식문자열로 %s를 사용해야함

	// cf) 괄호 안에서 더해지는 숫자는 Character로 취급 -> 이해안됨!!
	//		: 괄호없이 더해지는 숫자는 그냥 int의 바이트값인 4byte로 인식하여 2004번지가 됨
	//		ex) str[1] + 1 >> 2004번지로 인식

	printf("str[1][1] = %c\n", str[1][1]); // >> c
	*/

	// 3. 배열과 포인터 변수의 표기법
	/*
	// 3-1
	char str[10] = "ABCDEFG";

	printf("%c\n", str[1]); // >> B (문자출력)

	// 3-2
	char* str = "ABCDEFG";

	printf("%c\n", *(str + 1)); // >> B (문자출력)
	printf("%s\n", (str + 1)); // >> BCDEFG (1001번지, 문자열출력, 서식문자열로 %s를 사용해야함)

	// 배열에서의 str[1] == 포인터 변수에서의 *(str + 1) >> B만 출력 (해당 주소값의 데이터 하나만)
	// (str + 1) >> 해당 주소값부터 null까지(문자열 출력)
	
	// 정리 : 간접연산자 O -> 해당 주소 안의 데이터를 직접 가리키는 거라 해당 데이터만 의미(문자로 출력됨)
	//		  간접연산자 X -> 해당 주소값를 가리킴(주소값 안의 데이터가 null인 주소값까지 -> 문자열로 출력됨)
	*/
}